data.dlux.io {
    # CRITICAL: WebSocket handling MUST come first and be very specific
    @websockets {
        header Connection *Upgrade*
        header Upgrade websocket
        path /ws/*
    }
    
    reverse_proxy @websockets localhost:3010 {
        # Essential WebSocket headers - ORDER MATTERS
        header_up Host {host}
        header_up Origin {http.request.header.Origin}
        header_up Connection {http.request.header.Connection}
        header_up Upgrade {http.request.header.Upgrade}
        header_up Sec-WebSocket-Key {http.request.header.Sec-WebSocket-Key}
        header_up Sec-WebSocket-Version {http.request.header.Sec-WebSocket-Version}
        header_up Sec-WebSocket-Protocol {http.request.header.Sec-WebSocket-Protocol}
        header_up Sec-WebSocket-Extensions {http.request.header.Sec-WebSocket-Extensions}
        
        # Prevent any response modification
        header_down -Server
        
        # CRITICAL: Disable ALL buffering and caching
        flush_interval -1
        
        # Advanced transport settings for WebSocket stability
        transport http {
            # Disable response buffering completely
            response_buffer_size 0
            # Disable keep-alive timeouts that can interfere
            keep_alive off
            # Set proper timeouts for WebSocket
            dial_timeout 30s
            response_header_timeout 30s
        }
    }

    # Handle all other HTTP requests (MUST come after WebSocket handling)
    reverse_proxy localhost:3010 {
        header_up Host {host}
        header_up X-Real-IP {remote}
        header_up X-Forwarded-For {remote}
        header_up X-Forwarded-Proto {scheme}
    }
}

# Alternative minimal config for testing (if above doesn't work)
# data.dlux.io {
#     reverse_proxy localhost:3010 {
#         header_up Host {host}
#         header_up Origin {http.request.header.Origin}
#     }
# } 